<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Nic's 32nd Birthday RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #202020;
            --screen-bg: #8bac0f;
            --pixel-black: #0f380f;
            --border-color: #306230;
        }

        /* RESET – no fixed body; use full viewport height (iPhone-safe) */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        body {
            background-color: var(--screen-bg);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        /* MAIN GAME WRAPPER – fills iPhone screen */
        #game-root {
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh; /* iOS Safari */
            display: flex;
            justify-content: center;
            align-items: stretch;
            background: #8bac0f;
            padding-left: env(safe-area-inset-left, 0);
            padding-right: env(safe-area-inset-right, 0);
            padding-top: env(safe-area-inset-top, 0);
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        #game-container {
            width: 100%;
            max-width: 450px;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            image-rendering: pixelated;
        }

        /* Scanlines */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.12) 50%,
                rgba(0,0,0,0.12)
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        /* RPG Border */
        .rpg-border {
            border: 3px solid var(--pixel-black);
            border-radius: 4px;
            background-color: white;
            position: relative;
            box-shadow:
                inset 0 0 0 3px #8bac0f,
                inset 0 0 0 6px var(--pixel-black);
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        /* Portrait area – ~1/3 of the screen */
        .portrait-wrapper {
            flex: 0 0 33%;
            min-height: 110px;
            max-height: 230px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .portrait-container {
            width: min(38vw, 38vh);
            height: min(38vw, 38vh);
            max-width: 210px;
            max-height: 210px;
            position: relative;
            image-rendering: pixelated;
            margin-bottom: 1vh;
        }

        .portrait-base {
            width: 100%;
            height: 100%;
            background-image: url('Assets/large_portrait_base.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            transition: background-image 0.1s ease-in-out;
        }

        .mouth-overlay {
            position: absolute;
            inset: 0;
            background-image: url('Assets/large_portrait_mouth_open.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            visibility: hidden;
        }

        .mouth-open {
            visibility: visible;
        }

        /* Mini sprite smaller */
        .mini-avatar {
            width: 28px;
            height: 42px;
            background-image: url('Assets/small_sprite_full.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            image-rendering: pixelated;
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
            animation: bob 1s ease-in-out infinite;
        }

        @keyframes bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        /* Dialogue area – rest of screen */
        .dialogue-wrapper {
            flex: 1 1 67%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 0.5rem 0.5rem;
            padding-bottom: calc(env(safe-area-inset-bottom, 0) + 0.7rem);
            gap: 0.4rem;
        }

        #dialogue-box {
            flex: 1 1 auto;
            min-height: 0;       /* allow flex to shrink properly */
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        #dialogue-text-area {
            flex: 1 1 auto;
            position: relative;
            overflow: hidden; /* no scrolling; we paginate instead */
            min-height: 0;
        }

        #dialogue-text {
            font-size: 11px;
            line-height: 1.4;
            color: #000;
            padding-right: 0.35rem;
            padding-bottom: 1.1rem;
            word-break: break-word;
        }

        @media (min-width: 768px) {
            #dialogue-text {
                font-size: 13px;
            }
        }

        #speaker-name {
            font-size: 10px;
            letter-spacing: 0.08em;
        }

        .pixel-btn {
            background-color: white;
            border: 3px solid black;
            padding: 8px;
            cursor: pointer;
            text-align: left;
            transition: transform 0.1s;
            font-size: 11px;
            line-height: 1.35;
        }

        .pixel-btn:active {
            transform: scale(0.98);
            background-color: #f0f0f0;
        }

        .triangle-down {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--pixel-black);
            animation: blink 1s infinite;
            position: absolute;
            bottom: 6px;
            right: 6px;
            z-index: 30;
        }

        @keyframes blink { 50% { opacity: 0; } }

        .hidden { display: none !important; }

        #error-msg {
            background: red;
            color: white;
            padding: 8px;
            font-size: 9px;
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            z-index: 100;
            display: none;
            border: 2px solid white;
        }

        .pb-safe {
            padding-bottom: 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Start overlay takes full game-container */
        #start-overlay {
            position: absolute;
            inset: 0;
        }

        h1 {
            font-size: 20px;
        }

        @media (min-width: 768px) {
            h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body class="bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiM4YmFjMGYiLz48cmVjdCB3aWR0aD0iMiIgaGVpZ2h0PSIyIiB4PSIxMCIgeT0iMTAiIGZpbGw9IiM3YjlhMGIiLz48cmVjdCB3aWR0aD0iMiIgaGVpZ2h0PSIyIiB4PSIzMCIgeT0iMjUiIGZpbGw9IiM3YjlhMGIiLz48L3N2Zz4=')]">

<div id="game-root">
    <div id="game-container" class="shadow-2xl">
        <div class="scanlines absolute inset-0 z-[60] opacity-20 pointer-events-none"></div>

        <div id="error-msg"></div>

        <!-- Start Overlay -->
        <div id="start-overlay" class="z-50 bg-blackfangen flex flex-col items-center justify-center text-white p-6 gap-8 pb-safe">
            <h1 class="text-center text-green-400 leading-snug px-4">
                NIC'S BIRTHDAY QUEST
            </h1>

            <div class="flex flex-col items-center gap-6 w-full">
                <p id="loading-text" class="text-xs text-gray-500 mb-0">
                    Loading Party Assets...
                </p>
                <button id="start-btn"
                        class="hidden text-xs text-white mb-0 text-center px-5 py-2 border-2 border-white animate-pulse hover:text-green-400 hover:border-green-400 cursor-pointer transition-colors">
                    Start Adventure
                </button>
            </div>
        </div>

        <!-- Character Portrait Area -->
        <div class="portrait-wrapper">
            <div class="portrait-container">
                <div id="portrait-base" class="portrait-base"></div>
                <div id="mouth-layer" class="mouth-overlay"></div>
            </div>
        </div>

        <!-- Dialogue UI -->
        <div class="dialogue-wrapper">
            <div id="dialogue-box" class="rpg-border relative" onclick="handleDialogueClick()">
                <!-- Header -->
                <div class="flex items-center mb-2 border-b-2 border-green-900 pb-1 flex-shrink-0">
                    <div class="mini-avatar"></div>
                    <div id="speaker-name"
                         class="text-blue-900 font-bold uppercase tracking-widest ml-1">
                        Zac
                    </div>
                </div>

                <!-- Text Area -->
                <div id="dialogue-text-area">
                    <div id="dialogue-text">
                        <!-- Text injected here -->
                    </div>
                </div>

                <div id="next-arrow" class="triangle-down hidden"></div>
            </div>

            <div id="options-container" class="w-full flex flex-col gap-2 hidden mt-1">
                <!-- Options injected here -->
            </div>
        </div>
    </div>
</div>

<script>
    // --- ASSET LOADING ---
    (function loadAssets() {
        const btn = document.getElementById('start-btn');
        const loadText = document.getElementById('loading-text');
        const errorMsg = document.getElementById('error-msg');

        const requiredImages = [
            'Assets/large_portrait_base.png',
            'Assets/large_portrait_mouth_open.png',
            'Assets/small_sprite_full.png',
            'Assets/base_birthday_cake.png'
        ];

        let loadedCount = 0;

        requiredImages.forEach(src => {
            const img = new Image();
            img.onload = () => {
                loadedCount++;
                if (loadedCount === requiredImages.length) {
                    loadText.innerText = "Assets Loaded. Ready.";
                    loadText.classList.remove('text-gray-500');
                    loadText.classList.add('text-green-500');
                    btn.classList.remove('hidden');
                }
            };
            img.onerror = () => {
                errorMsg.style.display = 'block';
                errorMsg.innerText = `ERROR: Missing file '${src}'. Please check Assets folder.`;
                loadText.innerText = "Asset Missing";
                loadText.classList.remove('text-gray-500');
                loadText.classList.add('text-red-500');
            };
            img.src = src;
        });
    })();

    // --- STATE ---
    const gameState = {
        currentNode: 'start',
        pageIndex: 0,
        isTyping: false,
        fullText: '',
        typingSpeed: 30,
        timeouts: [],
        mouthInterval: null,
        isBirthdayMode: false,
        pages: [] // all pages for current node
    };

    let audioCtx;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playBlip() {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05);
        gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.05);
    }

    // --- CONVERSATION DATA ---
    const conversation = {
        'start': {
            text: [
                "System initialized...",
                "Hello Nic.",
                "I have been waiting for you."
            ],
            next: 'check_date'
        },
        'check_date': {
            text: [
                "My database indicates a 365-day cycle has completed...",
                "Am I therefore correct in saying it is your birthday today?"
            ],
            options: [
                { text: "Yes, it is!", next: 'confirm_age' },
                { text: "No, I'm sick and tired of clankers.", next: 'denial' }
            ]
        },
        'denial': {
            text: [
                "Incorrect...",
                "My calculations are precise to the millisecond.",
                "We will proceed as if it is..."
            ],
            next: 'confirm_age'
        },
        'confirm_age': {
            text: [
                "According to my calculations you have now arrived at Level 32.",
                "Congratulations on achieving such a feat!",
                "Question: Has the unit known as 'Zac' purchased you a beverage to commemorate this change of circumstance?"
            ],
            options: [
                { text: "Yes he has!", next: 'good_zac' },
                { text: "No, not yet.", next: 'bad_zac' }
            ]
        },
        'good_zac': {
            text: [
                "Acceptable...",
                "He is functioning within normal parameters.",
                "Status report: How is the evening?"
            ],
            options: [
                { text: "It's great!", next: 'joke_offer' },
                { text: "It's okay.", next: 'joke_offer' }
            ]
        },
        'bad_zac': {
            text: [
                "Unsatisfactory...",
                "He better get to it immediately.",
                "Status report: How is the evening otherwise?"
            ],
            options: [
                { text: "It's great!", next: 'joke_offer' },
                { text: "It's okay.", next: 'joke_offer' }
            ]
        },
        'joke_offer': {
            text: [
                "Noted...",
                "I have retrieved a humor file for this occasion.",
                "Would you like to hear it?"
            ],
            options: [
                { text: "Let's hear it.", next: 'joke_punchline' },
                { text: "Please no.", next: 'joke_punchline' }
            ]
        },
        'joke_punchline': {
            text: [
                "Aggression research hahahaha."
            ],
            next: 'birthday_reveal'
        },
        'birthday_reveal': {
            text: [
                "Protocol complete...",
                "Happy Birthday Nic!",
                "I really appreciate having you as a friend and hope you have an awesome day!"
            ],
            special: 'cake',
            options: [
                { text: "Start Over", next: 'HOME' }
            ]
        }
    };

    // --- DOM ELEMENTS ---
    const els = {
        overlay: document.getElementById('start-overlay'),
        startBtn: document.getElementById('start-btn'),
        text: document.getElementById('dialogue-text'),
        arrow: document.getElementById('next-arrow'),
        options: document.getElementById('options-container'),
        portraitBase: document.getElementById('portrait-base'),
        mouthLayer: document.getElementById('mouth-layer'),
        textArea: document.getElementById('dialogue-text-area')
    };

    // Height-based pagination: split text so it fits the visible box
    function paginateByHeight(textArray) {
        const areaEl = els.textArea;
        const textEl = els.text;

        if (!areaEl) return [];
        const maxHeight = areaEl.clientHeight || 0;

        // Fallback if something weird happens
        if (maxHeight === 0) {
            const pages = [];
            const maxChars = 80;
            textArray.forEach(t => {
                const words = t.split(' ');
                let current = '';
                for (const w of words) {
                    const candidate = current ? current + ' ' + w : w;
                    if (candidate.length > maxChars && current) {
                        pages.push(current);
                        current = w;
                    } else {
                        current = candidate;
                    }
                }
                if (current) pages.push(current);
            });
            return pages;
        }

        const pages = [];
        const originalVisibility = textEl.style.visibility;
        const originalHTML = textEl.innerHTML;

        textEl.style.visibility = 'hidden';
        textEl.innerHTML = '';

        const pushPage = (content) => {
            if (content && content.trim().length > 0) {
                pages.push(content.trim());
            }
        };

        textArray.forEach(t => {
            const words = t.split(' ');
            let current = '';

            for (const w of words) {
                const candidate = current ? current + ' ' + w : w;
                textEl.innerText = candidate;
                const needed = textEl.scrollHeight;

                if (needed > maxHeight && current) {
                    // current is the largest that fits
                    pushPage(current);
                    current = w;
                    textEl.innerText = current;
                } else {
                    current = candidate;
                }
            }

            if (current) {
                // check if the last bit fits, otherwise split again crudely
                textEl.innerText = current;
                if (textEl.scrollHeight > maxHeight) {
                    const words2 = current.split(' ');
                    let c2 = '';
                    for (const w2 of words2) {
                        const cand2 = c2 ? c2 + ' ' + w2 : w2;
                        textEl.innerText = cand2;
                        if (textEl.scrollHeight > maxHeight && c2) {
                            pushPage(c2);
                            c2 = w2;
                            textEl.innerText = c2;
                        } else {
                            c2 = cand2;
                        }
                    }
                    pushPage(c2);
                } else {
                    pushPage(current);
                }
            }
        });

        // restore
        textEl.innerHTML = originalHTML;
        textEl.style.visibility = originalVisibility;

        return pages;
    }

    // --- LOGIC ---

    function startApp() {
        els.overlay.classList.add('hidden');
        initAudio();
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        loadNode('start');
    }

    function resetToHome() {
        els.overlay.classList.remove('hidden');
        els.options.classList.add('hidden');
        els.arrow.classList.add('hidden');
        els.text.innerHTML = '';
        gameState.isBirthdayMode = false;
        gameState.pages = [];
        gameState.pageIndex = 0;
        els.portraitBase.style.backgroundImage = "url('Assets/large_portrait_base.png')";
        els.mouthLayer.style.visibility = 'hidden';
        if (gameState.mouthInterval) {
            clearInterval(gameState.mouthInterval);
            gameState.mouthInterval = null;
        }
    }

    function loadNode(nodeId) {
        if (nodeId === 'HOME') {
            resetToHome();
            return;
        }

        const node = conversation[nodeId];
        if (!node) return;

        gameState.currentNode = nodeId;
        gameState.pageIndex = 0;

        const rawTextArray = Array.isArray(node.text) ? node.text : [node.text];

        // Height-based pagination for the current viewport
        gameState.pages = paginateByHeight(rawTextArray);
        gameState.fullText = gameState.pages[0] || '';

        els.options.classList.add('hidden');
        els.arrow.classList.add('hidden');
        els.text.innerHTML = '';

        if (node.special === 'cake') {
            gameState.isBirthdayMode = true;
            els.portraitBase.style.backgroundImage = "url('Assets/base_birthday_cake.png')";
            els.mouthLayer.style.visibility = 'hidden';
            if (gameState.mouthInterval) {
                clearInterval(gameState.mouthInterval);
                gameState.mouthInterval = null;
            }
        } else {
            gameState.isBirthdayMode = false;
            els.portraitBase.style.backgroundImage = "url('Assets/large_portrait_base.png')";
        }

        if (gameState.fullText) {
            typeWriter(gameState.fullText, 0);
        }
    }

    function typeWriter(text, index) {
        gameState.isTyping = true;

        if (!gameState.mouthInterval && !gameState.isBirthdayMode) {
            els.mouthLayer.classList.add('mouth-open');
            gameState.mouthInterval = setInterval(() => {
                els.mouthLayer.classList.toggle('mouth-open');
            }, 100);
        }

        if (index < text.length) {
            els.text.innerHTML += text.charAt(index);
            if (index % 2 === 0) playBlip();

            const timeoutId = setTimeout(() => {
                typeWriter(text, index + 1);
            }, gameState.typingSpeed);
            gameState.timeouts.push(timeoutId);
        } else {
            finishTyping();
        }
    }

    function finishTyping() {
        gameState.timeouts.forEach(clearTimeout);
        gameState.timeouts = [];

        if (gameState.mouthInterval) {
            clearInterval(gameState.mouthInterval);
            gameState.mouthInterval = null;
        }
        els.mouthLayer.classList.remove('mouth-open');

        gameState.isTyping = false;
        els.text.innerHTML = gameState.fullText;

        const node = conversation[gameState.currentNode];

        if (gameState.pageIndex === gameState.pages.length - 1) {
            if (node.options) {
                showOptions(node.options);
                els.arrow.classList.add('hidden');
            } else {
                els.arrow.classList.remove('hidden');
            }
        } else {
            els.arrow.classList.remove('hidden');
        }
    }

    function showOptions(options) {
        els.options.innerHTML = '';
        els.options.classList.remove('hidden');

        options.forEach(opt => {
            const btn = document.createElement('div');
            btn.className = 'pixel-btn';
            btn.innerText = '> ' + opt.text;
            btn.onclick = (e) => {
                e.stopPropagation();
                loadNode(opt.next);
            };
            els.options.appendChild(btn);
        });
    }

    function handleDialogueClick() {
        const node = conversation[gameState.currentNode];

        if (gameState.isTyping) {
            finishTyping();
            return;
        }

        // If there are more pages for this node, advance
        if (gameState.pageIndex < gameState.pages.length - 1) {
            gameState.pageIndex++;
            gameState.fullText = gameState.pages[gameState.pageIndex];
            els.text.innerHTML = '';
            els.arrow.classList.add('hidden');
            typeWriter(gameState.fullText, 0);
        } else {
            // Finished all pages; either show options or go to next node
            if (node.options) {
                // options already visible
            } else if (node.next) {
                loadNode(node.next);
            }
        }
    }

    els.startBtn.addEventListener('click', startApp);

    // Re-paginate on orientation change so it still fits
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (gameState.currentNode && !els.overlay.classList.contains('hidden')) return;
            if (gameState.currentNode) {
                loadNode(gameState.currentNode);
            }
        }, 300);
    });
</script>
</body>
</html>
